<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EyeGaze Cursor Control</title>
    <style>
        :root {
            --primary: #2196f3;
            --secondary: #00bcd4;
            --bg: #ffffff;
            --surface: #f8f9fa;
            --text: #1a1f29;
            --cursor-color: rgba(33, 150, 243, 0.4);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* The Custom Cursor */
        #gaze-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 3px solid var(--primary);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px var(--primary);
            transition: transform 0.1s ease-out;
            display: none;
        }

        #gaze-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Bullet projectile */
        .bullet {
            position: fixed;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 12px #ff9800, 0 0 24px rgba(255, 152, 0, 0.5);
            transform: translate(-50%, -50%);
        }

        .bullet-trail {
            position: fixed;
            width: 4px;
            height: 4px;
            background: rgba(255, 235, 59, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9998;
            transform: translate(-50%, -50%);
        }

        /* Cursor impact effect */
        #gaze-cursor.impact {
            border-color: #ff4d4d !important;
            box-shadow: 0 0 30px #ff4d4d, 0 0 60px rgba(255, 77, 77, 0.4) !important;
            animation: cursorPulse 0.3s ease-out;
        }

        @keyframes cursorPulse {
            0% {
                transform: translate(-50%, -50%) scale(1.6);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .impact-ring {
            position: fixed;
            border: 2px solid rgba(255, 152, 0, 0.7);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9998;
            transform: translate(-50%, -50%);
            animation: ringExpand 0.4s ease-out forwards;
        }

        @keyframes ringExpand {
            0% {
                width: 10px;
                height: 10px;
                opacity: 1;
            }

            100% {
                width: 80px;
                height: 80px;
                opacity: 0;
            }
        }

        .ui-container {
            z-index: 100;
            text-align: center;
            background: var(--surface);
            padding: 30px;
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
            max-width: 400px;
        }

        h1 {
            margin-top: 0;
            font-weight: 300;
            letter-spacing: 1px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            color: rgba(0, 0, 0, 0.6);
            font-size: 15px;
            line-height: 1.6;
            font-weight: 500;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            color: #000;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 242, 254, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: #ff4d4d;
            color: white;
        }

        #status {
            margin-top: 15px;
            font-size: 12px;
            color: var(--primary);
            font-family: monospace;
        }

        #webcam-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid var(--primary);
            background: #000;
            opacity: 0.5;
            display: none;
        }

        /* Interaction grid for visual feedback */
        .grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            pointer-events: none;
        }

        .grid-cell {
            border: 1px solid rgba(0, 0, 0, 0.02);
        }

        /* Calibration Overlay */
        #calibration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            z-index: 20000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .calib-dot {
            position: absolute;
            width: 25px;
            height: 25px;
            background: var(--primary);
            border-radius: 50%;
            border: 4px solid #fff;
            box-shadow: 0 0 15px var(--primary);
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .calib-dot.active {
            transform: translate(-50%, -50%) scale(1.5);
            background: #ff4d4d;
            box-shadow: 0 0 30px #ff4d4d;
        }

        #calib-instruction {
            position: absolute;
            top: 45%;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: 300;
            color: #1a1f29;
        }

        .instructions-list {
            font-size: 13px;
            padding-left: 20px;
            color: rgba(0, 0, 0, 0.5);
            font-weight: 500;
        }

        .slider-group {
            margin-top: 20px;
            text-align: left;
        }

        .slider-label {
            font-size: 11px;
            text-transform: uppercase;
            opacity: 0.4;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }

        .slider-label span {
            opacity: 1;
            color: var(--primary);
            font-family: monospace;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            border: 3px solid var(--primary);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>

<body>

    <div class="grid">
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
        <div class="grid-cell"></div>
    </div>

    <div id="gaze-cursor"></div>

    <div id="calibration-overlay">
        <div id="calib-instruction">Look at the red dot</div>
        <div id="calib-dot" class="calib-dot"></div>
    </div>

    <video id="webcam-preview" autoplay playsinline></video>

    <div class="ui-container">
        <h1>EYE GAZE</h1>
        <p>Control your cursor using only your eyes. Look around the screen to navigate.</p>

        <button id="toggleBtn" class="btn">Start Gaze Control</button>
        <button id="calibBtn" class="btn"
            style="background: #e0e0e0; margin-left:10px; display:none;">Calibrate</button>
        <div id="status">System Offline</div>

        <div class="slider-group">
            <div class="slider-label">Sensitivity <span id="sensitivityValue">5000</span></div>
            <input type="range" id="sensitivitySlider" min="500" max="20000" value="5000" step="100">
        </div>

        <div style="margin-top: 40px; text-align: left;">
            <div
                style="font-size: 11px; text-transform: uppercase; opacity: 0.4; margin-bottom: 8px; font-weight: 700; color: var(--text);">
                Instructions:
            </div>
            <ul class="instructions-list">
                <li>Keep your head still for best results.</li>
                <li>The white background helps illuminate your face for the AI.</li>
                <li>Look at the center of the screen to calibrate.</li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const video = document.getElementById("webcam-preview");
        const toggleBtn = document.getElementById("toggleBtn");
        const calibBtn = document.getElementById("calibBtn");
        const status = document.getElementById("status");
        const cursor = document.getElementById("gaze-cursor");
        const calibOverlay = document.getElementById("calibration-overlay");
        const calibDot = document.getElementById("calib-dot");
        const calibInstruction = document.getElementById("calib-instruction");
        const sensitivitySlider = document.getElementById("sensitivitySlider");
        const sensitivityValue = document.getElementById("sensitivityValue");

        // Update sensitivity in real-time from slider
        sensitivitySlider.addEventListener("input", () => {
            sensitivity = parseInt(sensitivitySlider.value);
            sensitivityValue.textContent = sensitivity;
        });

        let faceLandmarker;
        let runningMode = "VIDEO";
        let webcamRunning = false;
        let lastVideoTime = -1;

        // Calibration state
        let isCalibrating = false;
        let calibPoints = [
            { x: 10, y: 10 }, { x: 50, y: 10 }, { x: 90, y: 10 },
            { x: 10, y: 50 }, { x: 50, y: 50 }, { x: 90, y: 50 },
            { x: 10, y: 90 }, { x: 50, y: 90 }, { x: 90, y: 90 }
        ];
        let currentCalibIndex = 0;
        let calibData = [];
        let calibResults = {
            minX: -0.2, maxX: 0.2,
            minY: -0.2, maxY: 0.2
        };

        // Relative cursor state
        let cursorX = window.innerWidth / 2;
        let cursorY = window.innerHeight / 2;

        // Previous gaze values for delta computation
        let prevGazeX = null;
        let prevGazeY = null;

        // Rolling history buffers for smoothing
        let gazeHistoryX = [];
        let gazeHistoryY = [];
        const historySize = 5;

        // Sensitivity multiplier: how many pixels per unit of nose position delta
        let sensitivity = 5000;

        // Minimum delta to count as intentional movement (noise gate)
        const threshold = 0.002;

        // --- Nose stability & blink detection state ---
        let noseStableFrames = 0;            // consecutive frames nose hasn't moved
        const noseStableThreshold = 8;       // frames before blink detection kicks in
        const blinkThreshold = 0.4;          // blendshape score to count as a blink
        let isBlinking = false;              // debounce: currently in a blink
        let blinkCooldown = false;           // cooldown after firing

        function average(arr) {
            if (arr.length === 0) return 0;
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        function resetGazeState() {
            prevGazeX = null;
            prevGazeY = null;
            gazeHistoryX = [];
            gazeHistoryY = [];
            cursorX = window.innerWidth / 2;
            cursorY = window.innerHeight / 2;
            noseStableFrames = 0;
            isBlinking = false;
            blinkCooldown = false;
        }

        // --- Bullet firing animation ---
        function fireBullet(targetX, targetY) {
            if (blinkCooldown) return;
            blinkCooldown = true;

            const startX = window.innerWidth / 2;
            const startY = window.innerHeight + 20;
            const bullet = document.createElement('div');
            bullet.className = 'bullet';
            bullet.style.left = startX + 'px';
            bullet.style.top = startY + 'px';
            document.body.appendChild(bullet);

            const duration = 250; // ms
            const startTime = performance.now();
            const trailInterval = 30;
            let lastTrailTime = 0;

            function animateBullet(now) {
                const elapsed = now - startTime;
                const t = Math.min(elapsed / duration, 1);
                // Ease-out for decelerating feel
                const easeT = 1 - Math.pow(1 - t, 3);

                const bx = startX + (targetX - startX) * easeT;
                const by = startY + (targetY - startY) * easeT;
                bullet.style.left = bx + 'px';
                bullet.style.top = by + 'px';

                // Leave trail particles
                if (now - lastTrailTime > trailInterval && t < 0.9) {
                    lastTrailTime = now;
                    const trail = document.createElement('div');
                    trail.className = 'bullet-trail';
                    trail.style.left = bx + 'px';
                    trail.style.top = by + 'px';
                    document.body.appendChild(trail);
                    setTimeout(() => trail.remove(), 200);
                }

                if (t < 1) {
                    requestAnimationFrame(animateBullet);
                } else {
                    // Impact!
                    bullet.remove();

                    // Cursor flash
                    cursor.classList.add('impact');
                    setTimeout(() => cursor.classList.remove('impact'), 300);

                    // Shockwave ring
                    const ring = document.createElement('div');
                    ring.className = 'impact-ring';
                    ring.style.left = targetX + 'px';
                    ring.style.top = targetY + 'px';
                    document.body.appendChild(ring);
                    setTimeout(() => ring.remove(), 400);

                    // Cooldown reset
                    setTimeout(() => { blinkCooldown = false; }, 500);
                }
            }

            requestAnimationFrame(animateBullet);
        }

        async function init() {
            status.innerText = "Initializing AI Models...";
            const filesetResolver = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: true,
                runningMode: runningMode,
                numFaces: 1
            });
            status.innerText = "System Ready";
            calibBtn.style.display = "inline-block";
        }

        init();

        toggleBtn.addEventListener("click", () => {
            if (!faceLandmarker) return;
            toggleTracking();
        });

        calibBtn.addEventListener("click", () => {
            if (!webcamRunning) {
                toggleTracking().then(() => startCalibration());
            } else {
                startCalibration();
            }
        });

        async function toggleTracking() {
            if (webcamRunning) {
                webcamRunning = false;
                toggleBtn.innerText = "Start Gaze Control";
                toggleBtn.classList.remove("active");
                cursor.style.display = "none";
                status.innerText = "Tracking Stopped";
                resetGazeState();
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
            } else {
                webcamRunning = true;
                toggleBtn.innerText = "Stop Gaze Control";
                toggleBtn.classList.add("active");
                cursor.style.display = "block";
                status.innerText = "Initializing Camera...";

                return new Promise((resolve) => {
                    const constraints = { video: true };
                    navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                        video.srcObject = stream;
                        video.addEventListener("loadeddata", () => {
                            predictWebcam();
                            resolve();
                        });
                    });
                });
            }
        }

        function startCalibration() {
            isCalibrating = true;
            currentCalibIndex = 0;
            calibData = [];
            calibOverlay.style.display = "flex";
            status.innerText = "Calibration In Progress";
            showNextCalibPoint();
        }

        function showNextCalibPoint() {
            if (currentCalibIndex >= calibPoints.length) {
                finishCalibration();
                return;
            }

            const pt = calibPoints[currentCalibIndex];
            calibDot.style.left = pt.x + "%";
            calibDot.style.top = pt.y + "%";
            calibDot.classList.add("active");

            // Give user time to focus
            setTimeout(() => {
                currentCalibIndex++;
                showNextCalibPoint();
            }, 2000);
        }

        function finishCalibration() {
            isCalibrating = false;
            calibOverlay.style.display = "none";

            // Calculate ranges based on collected data
            if (calibData.length > 0) {
                const xs = calibData.map(d => d.rawX);
                const ys = calibData.map(d => d.rawY);
                calibResults.minX = Math.min(...xs);
                calibResults.maxX = Math.max(...xs);
                calibResults.minY = Math.min(...ys);
                calibResults.maxY = Math.max(...ys);

                // Add some buffer (10%)
                const xBuf = (calibResults.maxX - calibResults.minX) * 0.1;
                const yBuf = (calibResults.maxY - calibResults.minY) * 0.1;
                calibResults.minX -= xBuf;
                calibResults.maxX += xBuf;
                calibResults.minY -= yBuf;
                calibResults.maxY += yBuf;
            }

            // Reset gaze state so cursor starts fresh from center
            resetGazeState();
            status.innerText = "Calibration Complete";
        }

        async function predictWebcam() {
            if (!webcamRunning) return;

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, startTimeMs);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    // --- Nose position (coarse control) ---
                    const noseTip = results.faceLandmarks[0][1];
                    const rawX = -noseTip.x;  // invert for mirrored webcam
                    const rawY = noseTip.y;

                    if (isCalibrating) {
                        calibData.push({ rawX, rawY });
                    } else {
                        // First frame: store nose position, don't move
                        if (prevGazeX === null) {
                            prevGazeX = rawX;
                            prevGazeY = rawY;
                        } else {
                            // Compute nose delta
                            let deltaX = rawX - prevGazeX;
                            let deltaY = rawY - prevGazeY;
                            prevGazeX = rawX;
                            prevGazeY = rawY;

                            // Push to rolling buffer for smoothing
                            gazeHistoryX.push(deltaX);
                            gazeHistoryY.push(deltaY);
                            if (gazeHistoryX.length > historySize) {
                                gazeHistoryX.shift();
                                gazeHistoryY.shift();
                            }

                            const smoothDeltaX = average(gazeHistoryX);
                            const smoothDeltaY = average(gazeHistoryY);

                            const noseMoving = Math.abs(smoothDeltaX) > threshold || Math.abs(smoothDeltaY) > threshold;

                            if (noseMoving) {
                                // --- NOSE MODE: coarse cursor movement ---
                                noseStableFrames = 0;

                                cursorX += smoothDeltaX * sensitivity;
                                cursorY += smoothDeltaY * sensitivity;

                                status.innerText = "Nose Tracking";
                            } else {
                                // Nose is still â€” count stable frames
                                noseStableFrames++;

                                if (noseStableFrames >= noseStableThreshold) {
                                    // --- BLINK DETECTION MODE ---
                                    if (results.faceBlendshapes && results.faceBlendshapes.length > 0) {
                                        const blendshapes = results.faceBlendshapes[0].categories;
                                        const getScore = (name) => blendshapes.find(c => c.categoryName === name)?.score || 0;

                                        const blinkLeft = getScore("eyeBlinkLeft");
                                        const blinkRight = getScore("eyeBlinkRight");
                                        const blinkDetected = blinkLeft > blinkThreshold || blinkRight > blinkThreshold;

                                        if (blinkDetected && !isBlinking) {
                                            isBlinking = true;
                                            fireBullet(cursorX, cursorY);
                                            status.innerText = "ðŸ’¥ FIRE!";
                                        } else if (!blinkDetected) {
                                            isBlinking = false;
                                            status.innerText = "Ready â€” Blink to Shoot ðŸŽ¯";
                                        }
                                    }
                                }
                            }

                            // Clamp to screen bounds
                            cursorX = Math.max(0, Math.min(window.innerWidth, cursorX));
                            cursorY = Math.max(0, Math.min(window.innerHeight, cursorY));

                            cursor.style.left = `${cursorX}px`;
                            cursor.style.top = `${cursorY}px`;
                        }
                    }
                } else {
                    status.innerText = "Face Not Detected";
                }
            }

            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        }
    </script>
</body>

</html>