<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Shooter - Left/Right Selection</title>
    <style>
        :root {
            --primary: #FF5722;
            --bg: #ffffff;
            --text: #1a1a2e;
            --balloon-color: #e94560;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Start / Calibration Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px var(--primary);
        }

        p {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.4);
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 87, 34, 0.8);
        }

        /* Game Area */
        #game-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Laser Canvas */
        #laser-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        /* Balloons */
        .balloon-container {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 150px;
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s ease-out, filter 0.2s;
        }

        /* Selection Box / Highlight */
        .balloon-container.locked .balloon {
            filter: drop-shadow(0 0 30px var(--primary)) brightness(1.2);
            transform: scale(1.15);
        }

        .balloon-container.locked::after {
            content: 'LOCKED';
            position: absolute;
            top: -40px;
            font-weight: bold;
            color: var(--primary);
            font-size: 1.5rem;
            text-shadow: 0 0 10px black;
            animation: pulse 0.3s infinite alternate;
        }

        @keyframes pulse {
            from {
                opacity: 0.6;
            }

            to {
                opacity: 1;
            }
        }

        .balloon {
            width: 120px;
            height: 150px;
            background: radial-gradient(circle at 30% 30%, #ff8a80, #d32f2f);
            border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%;
            box-shadow: inset -10px -10px 20px rgba(0, 0, 0, 0.3), 10px 10px 20px rgba(0, 0, 0, 0.2);
            position: relative;
            animation: float 3s ease-in-out infinite alternate;
            transition: transform 0.1s;
        }

        .balloon::before {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 15px solid #d32f2f;
        }

        .balloon::after {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 30px;
            /* Reflection */
            height: 15px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            transform: rotate(-45deg);
        }

        .wire {
            width: 2px;
            height: 100px;
            background: rgba(255, 255, 255, 0.5);
            margin-top: -5px;
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }

            100% {
                transform: translateY(-20px);
            }
        }

        /* Hit Effect */
        .balloon.hit {
            filter: brightness(2) !important;
            transform: scale(0.9) !important;
        }

        /* Popped Effect */
        .balloon.popped {
            transition: all 0.1s;
            transform: scale(0.1) !important;
            opacity: 0;
        }

        /* Webcam Preview */
        #webcam-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 2px solid var(--primary);
            border-radius: 10px;
            opacity: 0.5;
            z-index: 200;
        }

        /* Calibration Dots */
        .calib-dot {
            position: absolute;
            width: 40px;
            height: 40px;
            background: red;
            border-radius: 50%;
            border: 4px solid white;
            box-shadow: 0 0 20px red;
            display: none;
            transform: translate(-50%, -50%);
            z-index: 300;
        }

        /* Gaze Indicator Bars */
        #gaze-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #gaze-indicator {
            width: 4px;
            height: 100%;
            background: var(--primary);
            position: absolute;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            box-shadow: 0 0 10px var(--primary);
        }

        .zone-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>

<body>

    <!-- Webcam (Hidden mainly, shown in preview) -->
    <video id="webcam-preview" autoplay playsinline muted></video>

    <!-- UI Overlay for Start/Calibration -->
    <div id="start-screen">
        <h1 style="color:white; font-weight:bold;">GAZE SHOOTER</h1>
        <p style="color:#ccc;">Look Left/Right to Select. Blink to Shoot.</p>
        <button id="start-btn" class="btn">START CALIBRATION</button>
        <p id="status-msg" style="margin-top: 20px; font-size: 1rem; color: #aaa;">Loading AI Models...</p>
    </div>

    <!-- Calibration Dot -->
    <div id="calib-dot" class="calib-dot"></div>

    <!-- Gaze Feedback -->
    <div id="gaze-bar">
        <div class="zone-marker" style="left: 40%"></div>
        <div class="zone-marker" style="left: 60%"></div>
        <div id="gaze-indicator"></div>
    </div>

    <!-- Gameplay Area -->
    <div id="game-area">
        <!-- Laser Canvas -->
        <canvas id="laser-canvas"></canvas>

        <!-- Balloons will be added here dynamically -->
    </div>

    <!-- Audio Context -->
    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playLaserSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);

            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function playPopSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);

            gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
        }
    </script>

    <!-- Logic -->
    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // DOM Elements
        const video = document.getElementById('webcam-preview');
        const startBtn = document.getElementById('start-btn');
        const statusMsg = document.getElementById('status-msg');
        const startScreen = document.getElementById('start-screen');
        const gameArea = document.getElementById('game-area');
        const calibDot = document.getElementById('calib-dot');
        const laserCanvas = document.getElementById('laser-canvas');
        const gazeBar = document.getElementById('gaze-bar');
        const gazeIndicator = document.getElementById('gaze-indicator');
        const ctx = laserCanvas.getContext('2d');

        // Game State
        let gameState = 'LOADING'; // LOADING, IDLE, CALIBRATING, PLAYING
        let faceLandmarker = null;
        let lastVideoTime = -1;

        // Calibration Data
        let calibRanges = {
            minX: -0.1, maxX: 0.1
        };
        const calibPoints = [
            { x: 0.5, y: 0.5 }, // Center
            { x: 0.2, y: 0.5 }, // Left
            { x: 0.8, y: 0.5 }, // Right
            { x: 0.5, y: 0.5 }  // Center again
        ];
        let currentCalibPoint = 0;
        let tempCalibData = [];

        // Blink State
        let isBlinking = false;
        let lastBlinkTime = 0;
        const BLINK_THRESHOLD = 0.5;
        const BLINK_COOLDOWN = 400; // ms

        // Selection State
        let selectedSide = null; // 'left' | 'right' | null
        let smoothedNormX = 0.5;

        // Balloon State
        let balloons = {
            left: null,
            right: null
        };

        // Helper: Resize canvas
        function resizeCanvas() {
            laserCanvas.width = window.innerWidth;
            laserCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Initialization ---
        async function init() {
            try {
                const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1
                });

                statusMsg.innerText = "System Ready. Camera permission required.";
                startBtn.style.display = 'block';
                gameState = 'IDLE';

                startBtn.addEventListener('click', startCalibration);

            } catch (e) {
                statusMsg.innerText = "Error loading AI: " + e;
                console.error(e);
            }
        }
        init();

        // --- Camera & Loop ---
        async function startCalibration() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    gameState = 'CALIBRATING';
                    startScreen.style.display = 'none';
                    runCalibrationSteps();
                    predictWebcam();
                });
            } catch (e) {
                alert("Camera access denied!");
            }
        }

        // --- Calibration Logic ---
        function runCalibrationSteps() {
            if (currentCalibPoint >= calibPoints.length) {
                finishCalibration();
                return;
            }

            const pt = calibPoints[currentCalibPoint];
            calibDot.style.display = 'block';
            calibDot.style.left = (pt.x * 100) + '%';
            calibDot.style.top = (pt.y * 100) + '%';

            setTimeout(() => {
                // Point duration
                currentCalibPoint++;
                runCalibrationSteps();
            }, 1500);
        }

        function finishCalibration() {
            calibDot.style.display = 'none';

            // Compute scale from collected data
            if (tempCalibData.length > 0) {
                const xs = tempCalibData.map(d => d.x);
                // Simple outlier check or just min/max
                calibRanges.minX = Math.min(...xs);
                calibRanges.maxX = Math.max(...xs);

                // Add buffer
                const span = calibRanges.maxX - calibRanges.minX || 0.1;
                calibRanges.minX -= span * 0.1; // 10% buffer
                calibRanges.maxX += span * 0.1;
            }

            // Start Game
            gameState = 'PLAYING';
            gazeBar.style.display = 'block';
            spawnBalloon('left');
            spawnBalloon('right');
        }

        // --- Game Logic ---
        function spawnBalloon(side) {
            const bDiv = document.createElement('div');
            bDiv.className = 'balloon-container';
            if (side === 'left') {
                bDiv.style.left = '20px';
            } else {
                bDiv.style.right = '20px';
                bDiv.style.left = 'auto';
            }

            const balloon = document.createElement('div');
            balloon.className = 'balloon';

            const wire = document.createElement('div');
            wire.className = 'wire';

            bDiv.appendChild(balloon);
            bDiv.appendChild(wire);
            gameArea.appendChild(bDiv);

            balloons[side] = {
                el: bDiv,
                balloonEl: balloon,
                side: side,
                hp: 6,
                active: true
            };
        }

        function updateSelection(normX) {
            // normX: 0 = left, 1 = right
            // Zones: < 0.4 Left, > 0.6 Right

            let newSelection = null;
            if (normX < 0.40) newSelection = 'left';
            else if (normX > 0.60) newSelection = 'right';

            // Visual Update
            gazeIndicator.style.left = (normX * 100) + '%';

            if (newSelection !== selectedSide) {
                selectedSide = newSelection;

                // Update Locked Classes
                if (balloons.left && balloons.left.active) {
                    balloons.left.el.classList.toggle('locked', selectedSide === 'left');
                }
                if (balloons.right && balloons.right.active) {
                    balloons.right.el.classList.toggle('locked', selectedSide === 'right');
                }
            }
        }

        function shootLaser() {
            playLaserSound(); // Audio

            const startX = window.innerWidth / 2;
            const startY = window.innerHeight;

            // Target Logic
            let endX, endY;
            let targetBalloon = null;

            if (selectedSide && balloons[selectedSide] && balloons[selectedSide].active) {
                // Aim at center of selected balloon
                const rect = balloons[selectedSide].balloonEl.getBoundingClientRect();
                endX = rect.left + rect.width / 2;
                endY = rect.top + rect.height / 2;
                targetBalloon = balloons[selectedSide];
            } else {
                // Miss (Shoot straight up)
                endX = window.innerWidth / 2;
                endY = 0;
            }

            // Draw Laser Animation
            animateLaser(startX, startY, endX, endY);

            // Hit Logic
            if (targetBalloon) {
                hitBalloon(targetBalloon);
            }
        }

        function animateLaser(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = '#00fff2';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00fff2';
            ctx.stroke();

            // Fade Laser
            let opacity = 1.0;
            function fade() {
                opacity -= 0.15;
                ctx.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
                if (opacity > 0) {
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = '#00fff2';
                    ctx.lineWidth = 8 * opacity;
                    ctx.stroke();
                    ctx.restore();
                    requestAnimationFrame(fade);
                }
            }
            requestAnimationFrame(fade);
        }

        function hitBalloon(b) {
            b.hp--;

            // Visual Feedback
            b.balloonEl.classList.add('hit');
            setTimeout(() => b.balloonEl.classList.remove('hit'), 150);

            // Scale down based on HP
            const scale = 0.5 + (b.hp / 6) * 0.5; // Min 0.5 size
            b.balloonEl.style.transform = `scale(${scale})`;

            if (b.hp <= 0) {
                // Pop!
                playPopSound();
                b.active = false;
                b.balloonEl.classList.add('popped');

                // Respawn
                setTimeout(() => {
                    b.hp = 6;
                    b.active = true;
                    b.balloonEl.classList.remove('popped');
                    b.balloonEl.style.transform = `scale(1)`;
                }, 2000);
            }
        }

        // --- Loop ---
        async function predictWebcam() {
            let startTimeMs = performance.now();

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, startTimeMs);

                if (results.faceBlendshapes && results.faceBlendshapes.length > 0) {
                    const blendshapes = results.faceBlendshapes[0].categories;
                    const getScore = (name) => blendshapes.find(c => c.categoryName === name)?.score || 0;

                    // Eye Gaze X (Proxy)
                    // lookIn/lookOut
                    // Left Eye: In=Right, Out=Left
                    // Right Eye: In=Left, Out=Right
                    const lookLeft = getScore("eyeLookOutLeft") || getScore("eyeLookInRight");
                    const lookRight = getScore("eyeLookInLeft") || getScore("eyeLookOutRight");

                    // Composite Raw X
                    const rawX = (lookRight - lookLeft);

                    // Add Head Yaw for better stability?
                    // const headYaw = results.facialTransformationMatrixes... (requires different config/mode)
                    // Let's stick to eye + head tracking implicitly via calibration

                    // RECORD CALIBRATION DATA
                    if (gameState === 'CALIBRATING') {
                        tempCalibData.push({ x: rawX });
                    }

                    // PLAY LOOP
                    if (gameState === 'PLAYING') {
                        // Normalize 0..1
                        let normX = (rawX - calibRanges.minX) / (calibRanges.maxX - calibRanges.minX);
                        normX = Math.max(0, Math.min(1, normX)); // Clamp

                        // Smooth
                        smoothedNormX += (normX - smoothedNormX) * 0.1;

                        updateSelection(smoothedNormX);

                        // Blink Detection
                        const blinkLeft = getScore("eyeBlinkLeft");
                        const blinkRight = getScore("eyeBlinkRight");
                        const blinkScore = Math.max(blinkLeft, blinkRight);

                        if (blinkScore > BLINK_THRESHOLD) {
                            if (!isBlinking && (startTimeMs - lastBlinkTime > BLINK_COOLDOWN)) {
                                isBlinking = true;
                                lastBlinkTime = startTimeMs;
                                shootLaser(); // FIRE!
                            }
                        } else {
                            isBlinking = false;
                        }
                    }
                }
            }

            window.requestAnimationFrame(predictWebcam);
        }
    </script>
</body>

</html>